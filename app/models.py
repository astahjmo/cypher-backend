from pydantic import BaseModel, Field, HttpUrl, field_validator, ConfigDict
# Import necessary types for Pydantic v2 custom type handling
from typing import List, Optional, Dict, Any
from pydantic_core import core_schema
from datetime import datetime, timezone
from bson import ObjectId
import uuid

# --- Custom PyObjectId Class for Pydantic V2 ---
class PyObjectId(ObjectId):
    """
    Custom Pydantic V2 type for BSON ObjectId.
    Handles validation and serialization.
    """
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source_type: Any, handler: Any
    ) -> core_schema.CoreSchema:
        """
        Defines how Pydantic should handle validation for this type.
        Accepts ObjectId or a valid string representation.
        """
        object_id_schema = core_schema.union_schema(
            [
                # Allow ObjectId instances directly
                core_schema.is_instance_schema(ObjectId),
                # Allow strings and validate them
                core_schema.no_info_plain_validator_function(cls.validate_object_id),
            ],
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda v: str(v) # Always serialize to string
            ),
        )
        # Define the final schema for Python usage (returns PyObjectId instance)
        return core_schema.json_or_python_schema(
            json_schema=object_id_schema,
            python_schema=core_schema.union_schema(
                [core_schema.is_instance_schema(cls), object_id_schema] # Allow PyObjectId instances too
            ),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda v: str(v)
            ),
        )

    @classmethod
    def validate_object_id(cls, v: Any) -> ObjectId:
        """Validator function for Pydantic."""
        if isinstance(v, ObjectId):
            return v
        if isinstance(v, str) and ObjectId.is_valid(v):
            return ObjectId(v)
        raise ValueError("Invalid ObjectId")

    @classmethod
    def __get_pydantic_json_schema__(
        cls, core_schema: core_schema.CoreSchema, handler: Any
    ) -> Dict[str, Any]:
        """
        Defines how this type should be represented in JSON Schema (OpenAPI).
        """
        # Get the default schema representation generated by Pydantic
        json_schema = handler(core_schema)
        # Override to specify it's a string with format 'objectid'
        json_schema.update(type='string', format='objectid')
        return json_schema

# Helper function for timezone-aware UTC default factory
def now_utc():
    return datetime.now(timezone.utc)

# --- Base Model with Date Serialization Config ---
def serialize_datetime(dt: datetime) -> str:
    """Ensure datetime is UTC and format to ISO 8601 with Z."""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc) # Assume UTC if naive
    else:
        dt = dt.astimezone(timezone.utc) # Convert to UTC if aware but different timezone
    # Format with Z, limiting microseconds to 3 digits for compatibility
    dt_str = dt.strftime('%Y-%m-%dT%H:%M:%S.%f')
    return dt_str[:-3] + 'Z'

class BaseModelWithDates(BaseModel):
    """Base model providing common configuration including date serialization."""
    model_config = ConfigDict(
        populate_by_name=True, # Allows using alias like '_id' in initialization
        arbitrary_types_allowed=True, # Keep this for now, though PyObjectId is now defined
        json_encoders={
            # ObjectId: str, # REMOVED - PyObjectId class handles serialization now
            datetime: serialize_datetime # Keep custom serializer for datetimes
        }
    )

# --- Application Models ---
# Updated to use the new PyObjectId class

class User(BaseModelWithDates):
    """Represents a user authenticated via GitHub."""
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id") # Use PyObjectId directly
    github_id: int = Field(..., description="GitHub user ID")
    login: str = Field(..., description="GitHub username")
    name: Optional[str] = None
    email: Optional[str] = None
    avatar_url: Optional[str] = None
    github_access_token: Optional[str] = Field(None, description="User's GitHub OAuth token (Stored insecurely!)", exclude=True)
    created_at: datetime = Field(default_factory=now_utc)
    updated_at: datetime = Field(default_factory=now_utc)


class RepositoryConfig(BaseModelWithDates):
    """Configuration for automatic builds for a specific repository."""
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    user_id: PyObjectId = Field(..., description="Internal user ID this config belongs to")
    repo_full_name: str = Field(..., description="Full repository name (e.g., 'owner/repo')")
    auto_build_branches: List[str] = Field(default=[], description="List of branches configured for automatic builds")
    created_at: datetime = Field(default_factory=now_utc)
    updated_at: datetime = Field(default_factory=now_utc)


class BuildStatus(BaseModelWithDates):
    """Represents the status and details of a specific build job."""
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    user_id: PyObjectId = Field(..., description="Internal user ID who initiated the build")
    repo_full_name: str = Field(..., description="Repository being built")
    branch: str = Field(..., description="Branch being built")
    commit_sha: Optional[str] = None
    commit_message: Optional[str] = None
    k8s_job_name: Optional[str] = None
    status: str = Field(default="pending", description="Build status (e.g., pending, running, success, failed)")
    image_tag: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime = Field(default_factory=now_utc)
    updated_at: Optional[datetime] = Field(default_factory=now_utc) # Keep optional for updates
    message: Optional[str] = None


class BuildLog(BaseModelWithDates):
    """Represents a single log entry for a build."""
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    build_id: PyObjectId = Field(..., description="ID of the build this log belongs to")
    timestamp: datetime = Field(default_factory=now_utc, description="Timestamp of the log entry")
    type: str = Field(..., description="Type of log entry (e.g., status, log, error)")
    message: str = Field(..., description="The log message content")


# --- Container Runtime Configuration Models ---

class VolumeMapping(BaseModel):
    """Represents a host-to-container volume mapping."""
    host_path: str = Field(..., description="Path on the host machine")
    container_path: str = Field(..., description="Path inside the container")

class EnvironmentVariable(BaseModel):
    """Represents an environment variable for a container."""
    name: str = Field(..., description="Name of the environment variable")
    value: str = Field(..., description="Value of the environment variable")

class LabelPair(BaseModel):
    """Represents a key-value pair for container labels."""
    key: str = Field(..., description="Label key")
    value: str = Field(..., description="Label value")

class PortMapping(BaseModel):
    """Represents a port mapping for a container."""
    container_port: int = Field(..., description="Port inside the container")
    host_port: Optional[int] = Field(None, description="Port on the host machine (optional, Docker assigns if None)")
    protocol: str = Field(default="tcp", description="Protocol (tcp or udp)")

    @field_validator('protocol')
    def validate_protocol(cls, v):
        if v not in ['tcp', 'udp']:
            raise ValueError('Protocol must be tcp or udp')
        return v

class ContainerRuntimeConfig(BaseModelWithDates):
    """Stores runtime configuration settings for a container associated with a repository."""
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    user_id: Optional[PyObjectId] = Field(None, description="Internal user ID this config belongs to (set by backend)")
    repo_full_name: str = Field(..., description="Full repository name (e.g., 'owner/repo') this config applies to")
    scaling: int = Field(default=1, ge=0, description="Desired number of running container instances")
    volumes: List[VolumeMapping] = Field(default=[], description="List of volume mappings")
    environment_variables: List[EnvironmentVariable] = Field(default=[], description="List of environment variables")
    labels: List[LabelPair] = Field(default=[], description="List of key-value labels for the container")
    network_mode: Optional[str] = Field(None, description="Docker network mode (e.g., bridge, host, none, custom_network_name)")
    port_mappings: List[PortMapping] = Field(default=[], description="List of port mappings")
    # Removed the old 'network' field
    created_at: datetime = Field(default_factory=now_utc)
    updated_at: datetime = Field(default_factory=now_utc)

# --- Pydantic Models for API Requests/Responses (Not Documents) ---

class RepositoryConfigCreate(BaseModel):
    branches: List[str]

class RepositoryConfigResponse(BaseModelWithDates): # Inherit for date serialization
    id: PyObjectId = Field(..., alias="_id") # Map _id to id
    repo_full_name: str
    auto_build_branches: List[str]
    created_at: datetime
    updated_at: datetime

class BuildTriggerRequest(BaseModel):
    tag_version: str = Field(default="latest")

class BuildTriggerResponse(BaseModel):
    build_id: str # Keep as string for API response consistency
    message: str

class BuildStatusResponse(BaseModelWithDates): # Inherit for date serialization
    id: PyObjectId = Field(..., alias="_id")
    repo_full_name: str
    branch: str
    commit_sha: Optional[str] = None
    commit_message: Optional[str] = None
    status: str
    image_tag: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    message: Optional[str] = None

class BuildLogResponse(BaseModelWithDates): # Inherit for date serialization
    timestamp: datetime
    type: str
    message: str

# --- Container API Models ---

class ContainerRuntimeConfigUpdate(BaseModel):
    """Fields that can be updated via PUT /api/v1/containers/{owner}/{repo}/config"""
    scaling: Optional[int] = Field(None, ge=0)
    volumes: Optional[List[VolumeMapping]] = None
    environment_variables: Optional[List[EnvironmentVariable]] = None
    labels: Optional[List[LabelPair]] = None
    network_mode: Optional[str] = None # Added network_mode
    port_mappings: Optional[List[PortMapping]] = None # Added port_mappings
    # Removed old 'network' field

class ContainerRuntimeConfigResponse(BaseModelWithDates): # Inherit for date serialization
    """Response model for GET /api/v1/containers/{owner}/{repo}/config"""
    id: PyObjectId = Field(..., alias="_id")
    repo_full_name: str
    scaling: int
    volumes: List[VolumeMapping]
    environment_variables: List[EnvironmentVariable]
    labels: List[LabelPair]
    network_mode: Optional[str] = None # Added network_mode
    port_mappings: List[PortMapping] = [] # Added port_mappings (default empty list)
    # Removed old 'network' field
    created_at: datetime
    updated_at: datetime

class ContainerDetail(BaseModel):
    id: str # Short ID
    name: str
    status: str # e.g., 'running', 'exited', 'paused'
    image: str
    # Updated ports structure to match docker client output more closely
    ports: Dict[str, Optional[List[Dict[str, str]]]] = Field(default_factory=dict, description="Docker port mapping structure (e.g., {'80/tcp': [{'HostIp': '0.0.0.0', 'HostPort': '8080'}]})")

class ContainerStatusResponse(BaseModel):
    repo_full_name: str
    running: int
    stopped: int
    paused: int
    memory_usage_mb: Optional[float] = None # Optional resource usage
    cpu_usage_percent: Optional[float] = None # Optional resource usage
    containers: List[ContainerDetail] = [] # List of individual containers

class ScaleRequest(BaseModel):
    desired_instances: int = Field(..., ge=0)

class ScaleResponse(BaseModel):
    repo_full_name: str
    message: str
    requested_instances: int
